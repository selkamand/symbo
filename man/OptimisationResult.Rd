% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/classes.R
\name{OptimisationResult}
\alias{OptimisationResult}
\title{Optimisation result for two aligned molecules}
\usage{
OptimisationResult(
  shapeclass = "NotSpecified",
  mol1 = structures::Molecule3D(),
  mol2 = structures::Molecule3D(),
  min_sum_of_squared_distance = NaN,
  angle_between_dummy_binding_vectors = NaN,
  mol1_phi = NaN,
  mol2_phi = NaN,
  mol1_slide = NaN,
  mol2_slide = NaN,
  mol1_axis = c(NaN, NaN, NaN),
  mol2_axis = c(NaN, NaN, NaN),
  n_calls_to_fn = 0,
  n_calls_to_gr = 0,
  convergence = NA_real_,
  message = NA_character_,
  hessian = 2
)
}
\arguments{
\item{mol1}{A \code{\link[structures:Molecule3D]{structures::Molecule3D}} object giving the
optimised coordinates of the first molecule. Defaults to an empty
\code{Molecule3D()} instance.}

\item{mol2}{A \code{\link[structures:Molecule3D]{structures::Molecule3D}} object giving the
optimised coordinates of the second molecule. Defaults to an empty
\code{Molecule3D()} instance.}
}
\value{
A new \code{OptimisationResult} S7 object with the supplied molecules and
all other fields initialised to their type-appropriate defaults.
}
\description{
\code{OptimisationResult} is an S7  object that stores the outcome of
a geometric optimisation used to align two \code{\link[structures:Molecule3D]{structures::Molecule3D}}
objects. It records the optimised geometries of each molecule, the
optimisation objective, key geometric parameters (angles, slides and
axes) and bookkeeping information returned by the optimiser.
}
\section{Fields}{


The class has the following properties:

\describe{

\item{mol1}{A \code{\link[structures:Molecule3D]{structures::Molecule3D}} object representing
the first input molecule in its geometrically optimised form (i.e.,
after applying the optimal rotation/translation that minimises
\code{min_sum_of_squared_distance}).}

\item{mol2}{A \code{\link[structures:Molecule3D]{structures::Molecule3D}} object representing
the second input molecule in its geometrically optimised form.}

\item{min_sum_of_squared_distance}{Numeric scalar giving the
minimised sum of squared distances between the dummy atoms of each
molecule and the opposing binding atom. Formally:
\eqn{d_1^2 + d_2^2}, where \eqn{d_1} is the distance from the mol1
dummy atom to the mol2 binding atom, and \eqn{d_2} is the distance
from the mol2 dummy atom to the mol1 binding atom, evaluated at the
optimum.}

\item{angle_between_dummy_binding_vectors}{Numeric scalar (radians)
giving the angle between the vector from mol1 dummy \eqn{\to} mol1
binding atom and the vector from mol2 dummy \eqn{\to} mol2 binding
atom, computed for the optimised geometry. For a “perfect” solution
this angle would be \eqn{\pi} (180 degrees).}

\item{mol1_phi}{Numeric scalar (radians): the optimal rotation angle
applied to \code{mol1} about \code{mol1_axis} to obtain the geometrically
optimal configuration.}

\item{mol2_phi}{Numeric scalar (radians): the optimal rotation angle
applied to \code{mol2} about \code{mol2_axis}.}

\item{mol1_slide}{Numeric scalar giving the optimal distance to
translate \code{mol1} along \code{mol1_axis} (the “slide” along the axis)
in the optimal configuration.}

\item{mol2_slide}{Numeric scalar giving the optimal distance to
translate \code{mol2} along \code{mol2_axis}.}

\item{mol1_axis}{Numeric length-3 vector describing the Cartesian
direction of the symmetry axis about which \code{mol1} was rotated and
along which it was slid during optimisation.}

\item{mol2_axis}{Numeric length-3 vector describing the corresponding
axis for \code{mol2}.}

\item{n_calls_to_fn}{Numeric scalar giving the number of calls to
the objective function (\code{fn}) made by the optimiser.}

\item{n_calls_to_gr}{Numeric scalar giving the number of calls to
the gradient function (\code{gr}) made by the optimiser (where applicable).}

\item{convergence}{Numeric scalar convergence code, typically matching
the codes returned by \code{\link[stats:optim]{stats::optim()}}. For example:
\itemize{
\item \code{0} – successful completion (method-dependent).
\item \code{1} – iteration limit (\code{maxit}) reached.
\item \code{10} – degeneracy of the Nelder–Mead simplex.
\item \code{51} – warning from method \code{"L-BFGS-B"} (see \code{message}).
\item \code{52} – error from method \code{"L-BFGS-B"} (see \code{message}).
}
See the documentation of the optimisation routine for exact meanings.}

\item{message}{Character scalar giving any additional information
returned by the optimiser (e.g. warnings, diagnostic messages). May be
\code{NA_character_} if no message is available.}

\item{hessian}{Numeric object (typically a symmetric matrix) giving an
estimate of the Hessian at the solution, if available. This is usually
the Hessian of the \emph{unconstrained} problem, even if box constraints are
active. If the optimisation was run without requesting a Hessian, this
property is set to \code{NaN}. Assigning \code{NULL} to \code{hessian} will also store
\code{NaN} internally.}

}
}

\section{Typical usage}{


Instances of \code{OptimisationResult} are usually created internally by
higher-level alignment / docking routines, and returned as a structured
record of the optimisation outcome for a given shape class or binding
mode.
}

\examples{
# (Pseudo-example; real usage would normally be through an optimiser)
res <- OptimisationResult(
  mol1 = Molecule3D(),
  mol2 = Molecule3D()
)
res@min_sum_of_squared_distance <- 0.12
res@n_calls_to_fn <- 35

}
