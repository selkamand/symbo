% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/maths.R
\name{rotate_vector_to_align_with_target}
\alias{rotate_vector_to_align_with_target}
\title{Rotate a 3D vector to align with a target direction (Rodrigues' formula)}
\usage{
rotate_vector_to_align_with_target(
  v,
  target,
  tol = 1e-08,
  return = c("vprime", "axis_plus_angle")
)
}
\arguments{
\item{v}{Numeric length-3 vector. The vector to rotate (need not be unit length).}

\item{target}{Numeric length-3 vector. Direction to align \code{v} with (need not be unit;
only direction matters).}

\item{tol}{Numeric scalar. Tolerance for detecting degeneracies (parallel/opposite/zero norms).}

\item{return}{Character; either \code{"vprime"} (default) to return the rotated vector,
or \code{"axis_plus_angle"} to return a list with rotation axis and angle.}
}
\value{
A numeric length-3 vector \code{v_prime} representing \code{v} rotated so that its
direction aligns with \code{target}. The \emph{magnitude} of \code{v_prime} matches \code{||v||}.
If return = "axis_plus_angle" returns a unit-vector rotation axis and angle that can be applied in \code{rotate_vector_around_axis()}
}
\description{
Rotates a 3D vector \code{v} so that its \emph{direction} aligns with the
direction of \code{target}, using Rodrigues' rotation formula.
The returned vector preserves the original length of \code{v}.
}
\details{
Let \eqn{\mathbf{u} = \frac{\mathbf{v}}{\|\mathbf{v}\|}} and
\eqn{\mathbf{t} = \frac{\mathbf{target}}{\|\mathbf{target}\|}} be unit vectors.
Define \eqn{\theta = \arccos(\mathbf{u}\cdot\mathbf{t})} and rotation axis
\eqn{\mathbf{k} = \frac{\mathbf{u}\times\mathbf{t}}{\|\mathbf{u}\times\mathbf{t}\|}} (if not degenerate).

Rodrigues' rotation formula rotates any vector \eqn{\mathbf{x}} about unit axis \eqn{\mathbf{k}}
by angle \eqn{\theta} via:
\deqn{
  \mathrm{Rot}_{\mathbf{k},\theta}(\mathbf{x}) =
  \mathbf{x}\cos\theta + (\mathbf{k}\times\mathbf{x})\sin\theta + \mathbf{k}\,(\mathbf{k}\cdot\mathbf{x})(1-\cos\theta).
}
This function applies the formula to \eqn{\mathbf{v}} with \eqn{\mathbf{k}} chosen to rotate
\eqn{\mathbf{u}} toward \eqn{\mathbf{t}} (right-hand rule).

Edge cases handled:
\itemize{
\item \strong{Already aligned} (\eqn{\theta \approx 0}): returns \code{v} unchanged.
\item \strong{Opposite directions} (\eqn{\theta \approx \pi}): chooses a stable axis orthogonal to \code{v}
and applies the \eqn{180^\circ} rotation (closed form).
\item \strong{Numerical safety}: clamps the dot product to \code{[-1, 1]} before \code{acos}.
}
}
\section{Potential pitfalls}{

\itemize{
\item \strong{Zero vectors:} If \code{v} or \code{target} has (near) zero norm,
rotation is undefined;
\item \strong{Axis normalization:} The rotation axis must be a \emph{unit} vector. We automatically scale non-unit target vectors
\item \strong{180° case:} When \code{v} and \code{target} are opposite, \code{u × t = 0} and the axis
is not defined. We choose a stable axis orthogonal to \code{v} automatically.
}
}

\examples{
# 1) Simple 90° rotation around z: (1,0,0) -> (0,1,0) when target = (0,1,0)
rotate_vector_to_align_with_target(c(1,0,0), c(0,1,0))

# 2) Align arbitrary v with (1,1,1): direction matches, length preserved
v      <- c(2, -3, 4)
target <- c(1, 1, 1)
v_rot  <- rotate_vector_to_align_with_target(v, target)
sqrt(sum(v^2))            # original length
sqrt(sum(v_rot^2))        # same length
cor(v_rot, target)        # ~ 1 (directions aligned)

# 3) Opposite directions (180°): target is -v's direction
v      <- c(1, 2, 3)
target <- -v
rotate_vector_to_align_with_target(v, target)

# 4) Input validation
\dontrun{
rotate_vector_to_align_with_target(c(0,0,0), c(1,0,0))  # error: zero-norm v
rotate_vector_to_align_with_target(c(1,0,0), c(0,0,0))  # error: zero-norm target
}

}
\references{
Rodrigues, O. (1840). \emph{Des lois géométriques qui régissent les déplacements d’un système solide dans l’espace}.
}
\seealso{
\code{rotations::genR()} (CRAN) for generating rotation matrices via Rodrigues’ formula.
}
